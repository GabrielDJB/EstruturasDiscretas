%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Estruturas Discretas - Segundo Trabalho
% LaTeX File to convert into PDF
% Final Version
%
% Original author:
% Lucas Rodrigues - 1510848
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size
\usepackage{float}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[portuguese]{babel} % Portuguese language/hyphenation
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering\normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header
\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

\usepackage{listings} % Put lists to place python code
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}
\restylefloat{table}

%----------------------------------------------------------------------------------------
% TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{
\normalfont \normalsize 
\textsc{Período de 2017.1} \\
\textsc{Prof. Marcus Vinicius S. Poggi de Aragão} \\
\textsc{Pontifícia Universidade Católica do Rio de Janeiro} \\  [0.5cm] % Your university, school and/or department name(s)
\horrule{1pt} \\  % Thin top horizontal rule
\LARGE Estruturas Discretas - Segundo Trabalho \\ % The assignment title
\horrule{2pt} \\ % Thick bottom horizontal rule
}

\author{
\large Gabriel Barbosa Diniz \\
\large 1511211 \and 
\large Lucas Rodrigues \\ 
\large 1510848 \and 
\large Mateus Ribeiro de Castro \\ 
\large 1213068 \\
}

\date{\scshape\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

\textbf{Observação$_1$}: Os códigos fontes dos algoritmos referentes aos teoremas provados seguirá em anexo em um arquivo Jupyter Notebook para melhor entendimento, compilação, execução, testes, etc.

%----------------------------------------------------------------------------------------
% PROBLEM 1
%----------------------------------------------------------------------------------------

\section{Primeiro Teorema}

\paragraph{Enunciado do Teorema}: Sabe-se encontrar a árvore de peso máximo de $G=(V,E)$ que contém o vértice 1 e possui $K$ vértices.\\

\begin{itemize}
   \item Denomina-se $A_k$ a árvore obtida com certo valor de $k$.
   \item Denomina-se $V_k$ e $E_k$ as listas de vértices e arestas, respectivamente, que compõem a árvore $A_k$.
\end{itemize}

\textbf{Caso Base}: Provando por indução simples em $K$, temos para o caso base $k=1$, e assim haverá somente o vértice $1$ e nenhuma aresta; o peso total será $0$. Esta é a única árvore possível de 1 vértice e que contém $v_1$. Está definida por $V_1 = \{v_1\}$ e $E_1 = \emptyset$.\\

\textbf{Hipótese Indutiva}: Pela hipótese indutiva, temos que o teorema é válido para $k$ vértices e desejamos provar, portanto, que é válido também para $k+1$ vértices. Portanto, conhecemos $V_k$ e $E_k$, e deseja-se determinar $V_{k+1}$ e $E_{k+1}$.\\

\textbf{Passo Indutivo}: Considere o grafo $B_k$ formado pelos vértices pertencentes a $V - V_k$ e por todas as arestas formadas por vértices $(b_1, b_2) \in (V - V_k)$. Considere o conjunto $R$ de arestas do tipo $(a, b)$ em que $a \in A_k$ e $b \in B_k$. Necessariamente, $A_{k+1}$ tem seu conjunto de vértices definido por $V_k \cup \{b\}$ e seu conjunto de arestas definido por $E_k \cup \{(a, b)\}$. Determinando $a$ e $b$, portanto, determinamos inteiramente $A_{k+1}$, onde $a$ e $b$ são os vértices da aresta de maior peso entre as arestas $R$. Com isso, está determinado $A_{k+1}$.\\

Com isso então podemos, através da prova indutiva resolvida derivar um algoritmo genérico que corresponde a prova deste teorema. Segue abaixo então o algoritmo em \emph{\textbf{python}}: \\

\begin{lstlisting}[language=Python, caption=Python algorithm]
import numpy as np

################################################################################
#
# Algoritmo que recebe uma matriz de adjascencias com os pesos das arestas
#
# OBS: Ao inves de usar varios parametros, procure usar o retorno multiplo,
#      retornando o visited e a arvore. No caso, base tenta retornar uma matriz
#      vazia com o visited incluindo o primeiro vertice.
#
################################################################################

def HeavyTree(M,k):

    n = len(M)
    
    if(k > n or k < 0):
        print("K invalido")
        return -1
    
    # Caso Base
    if(k == 1):
        visited = [0]
        tree = np.zeros((n,n))
        return tree, visited
    
    tree, visited = HeavyTree(M,k-1)
    B = [] # Vertices vizinhos a vertices visitados
    
    for i in range(n):
        if(i not in visited): # Aqui temos a avaliacao de todos os vertices
            for j in visited: # nao visitados que sao vizinhos de vertices 
                if(M[i,j] != 0 and j not in B): # visitados.
                    B = B + [i]
                    break
    
    biggest = 0
    new_v = 0
    old_v = 0
    
    for i in B:
        #new = np.max(M[i])
        for j in visited:
            if (M[i,j] > biggest):
                biggest = M[i,j]
                new_v = i
                old_v = j
    
    visited = visited + [new_v]
    
    #for i in range(n):
    #    if(M[new_v,i] == biggest):
    #        tree[i][new_v] = biggest
    #        tree[new_v][i] = biggest
    #        break
    
    tree[new_v][old_v] = biggest
    tree[old_v][new_v] = biggest
    
    return tree, visited
\end{lstlisting}

\paragraph{Observação sobre o algoritmo realizado}: Por questão prática do algoritmo em si, podemos dizer que foi realizado como passo indutivo:

\begin{itemize}
   \item Procura-se $max(T(k))$.
   \item Soma os pesos das arestas de maior peso de cada uma das folhas.
   \item Para todos os nós, adicionam-se as arestas de maior peso com os vértices restantes, ou seja, $max(p_b t.q b \in (V - V_k))$.
\end{itemize}

Dessa forma, saberemos que adicionamos as arestas de maior peso, e à medida que se aumenta $k$ basta incluirmos mais arestas de maior peso. \\

\textbf{Testes do Algoritmo}: A tabela abaixo ilustra o tempo de execução do algoritmo para diferentes instâncias e com diferentes valores do parâmetro $k$. O tempo foi medido executando o algoritmo por 5 segundos e contando o número de execuções.

%
%
%
%
%
%
%
%
%
%
%
% COLOCAR TABELA 
%
%
%
%
%
%
%
%
%
%
%
%

\pagebreak

%------------------------------------------------

\subsection{Teorema Bônus}

\paragraph{Enunciado do Teorema Bônus}: Sabe-se encontrar a floresta de peso mínimo de de $G=(V,E)$ onde os componentes conexos possuem pelo menos $k$ vértices. \\

\textbf{Caso Base}: Por indução simples em $k$. Para o caso base $k = 1$, a floresta $F_1$ conterá todos os vértices de $V$, porém nenhuma aresta. Assim, haverá $|V|$ componentes conexas e a soma dos pesos será mínima. \\

\textbf{Hipótese Indutiva}: Pela hipótese indutiva, temos que o teorema é válido para $k$ vértices e desejamos provar, portanto, que é válido também para $k+1$ vértices. Podemos definir componente conexo como qualquer árvore $A=(V',E')$ tal que $V'\subset V$, $E'\subset E$ e $|E'|>0$. Pela hipótese indutiva, um componente conexo de $F_k$ possuirá pelo menos $k$ vértices. \\

\textbf{Passo Indutivo}: Sendo assim, o único modo de garantir que este componente passe a conter pelo menos $k+1$ vértices é adicionando um novo vértice a este componente. Então, enquanto houverem componentes conexos em $F_{k+1}$ com número de vértices menores que $k+1$, devemos, do conjunto de arestas de $G$ ainda não utilizadas em $F_{k+1}$ (\textit{i.e.,} $S_k=E-E_{k+1}$), para um componente conexo A de $F_{k+1}$, escolher a aresta de menor peso $s=(v_1,v_2)\in S_k$ tal que $v_1 \in A$ e $v_2 \notin A$. Após a inclusão dessa aresta, o conjunto de componentes conexos deve ser re-avaliado. Desta maneira, todo componente conexo contará com pelo menos $k+1$ vértices e, assim, obteremos $F_{k+1}$, provando o teorema. \\

O algoritmo derivado desta prova indutiva é conhecido como \emph{\textbf{Algoritmo de Borůvka}} e é utilizado para se obter a Árvore Geradora Mínima de grafos ponderados cujos pesos das arestas são distintos. Segue abaixo o algoritmo em \emph{\textbf{Python}}:\\

\begin{lstlisting}[language=Python, caption=Python algorithm]
from pygraph.classes.graph import graph
from pygraph.algorithms.accessibility import connected_components

def teo_2(g, k):
  
  # Salvaguarda
  if k > len(g.nodes()):
    raise ValueError('FORBIDDEN: K > |V|')
  
  if k <= 0:
    raise ValueError('FORBIDDEN: K <= 0')

  # Caso base
  if k == 1:
    forest = graph()
  
    for node in g.nodes():
      forest.add_node(node)
  
    return forest

  # Hipotese indutiva
  forest = teo_2(g, k-1)

  # Enquanto ainda houverem componentes conexos
  # que nao satisfazem a condicao
  
  while True:
    # Atualiza a lista de componentes, pois pode ter
    # mudado durante a adicao
    cc = _transform_cc(connected_components(forest))

    # Seleciona um que tenha comprimento < k
    selected_component = None
    for component in cc:
      if len(component) < k:
        selected_component = component
        break

    # Se nao conseguiu selecionar, significa que todos
    # satisfazem comprimento >= k, e podemos parar o while
    if selected_component == None:
      break

    # Caso haja um selecionado, selecionar a aresta de menor
    # peso que tenha somente um dos vertices em selected_component
    edges = g.edges()
    used_edges = forest.edges()
    unused_edges = [e for e in edges if e not in used_edges]
    neighbor_edges = [e for e in unused_edges if e[0] in selected_component]

    min_edge = min(neighbor_edges, key=lambda e: g.edge_weight(e))
    forest.add_edge(min_edge)

  return forest


def _transform_cc(cc):
  
  inv_map = {}
  
  for k, v in cc.iteritems():
    inv_map[v] = inv_map.get(v, [])
    inv_map[v].append(k)
  
  return inv_map.values()
\end{lstlisting}

\textbf{Testes do Algoritmo}: A tabela abaixo ilustra o tempo de execução do algoritmo, em milissegundos, para diferentes instâncias e com diferentes valores do parâmetro $k$. 

\begin{itemize}
   \item O tempo foi medido executando o algoritmo por 5 segundos e contando o número de execuções.
\end{itemize}

\paragraph{Observação sobre os testes}: No anexo enviado estão figuras que ilustram o passo-a-passo dos vértices e arestas escolhidos em cada etapa do algoritmo quando aplicado na instância ulysses16.

\begin{table}[H]
\centering
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
entrada & $k=1$ & $k=2$ & $k=3$ & $k=5$ & $k=10$ & $k=15$ & $k=20$ & $k=30$ & $k=40$ & $k=50$ \\\hline
ulysses16 & 0.01 & 1.41 & 1.99 & 2.31 & 3.35 & 3.64 & -- & -- & -- & -- \\
ulysses22 & 0.01 & 3.09 & 4.66 & 6.36 & 23.57 & 24.95 & 25.02 & -- & -- & -- \\
bays29 & 0.01 & 7.37 & 11.36 & 14.04 & 21.32 & 21.58 & 21.86 & -- & -- & -- \\
eil51 & 0.02 & 59.49 & 98.04 & 148.13 & 163.11 & 170.35 & 173.74 & 175.71 & 175.82 & 183.72 \\
eil76 & 0.03 & 284 & 393 & 539 & 610 & 770 & 818 & 855 & 861 & 865 \\
bier127 & 0.06 & 1861 & 3127 & 3917 & 6735 & 8142 & 10210 & 10352 & 10996 & 13077
\end{tabular}
\end{table}

%----------------------------------------------------------------------------------------

\end{document}